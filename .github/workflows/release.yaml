name: Release NVRC

on:
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  id-token: write # Required for OIDC authentication with Sigstore

jobs:
  preflight:
    runs-on: ubuntu-24.04
    outputs:
      tag: ${{ steps.reltag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Install tomlq
        run: |
          python3 -m pip install --user yq
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Derive tag from Cargo.toml
        id: reltag
        shell: bash
        run: |
          set -euo pipefail
          ver=$(tomlq -r '.package.version' Cargo.toml)
          if [[ -z "$ver" ]]; then
            echo "Failed to extract version from Cargo.toml (package.version)" >&2
            exit 1
          fi
          echo "tag=v${ver}" >> "$GITHUB_OUTPUT"

      - name: Fail if Release already exists for this tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.reltag.outputs.tag }}"
          if gh release view "$TAG" --repo "${{ github.repository }}" >/dev/null 2>&1; then
            echo "Release $TAG already exists. Aborting to avoid overwrite." >&2
            exit 1
          fi

      - name: Ensure git tag exists (lightweight)
        shell: bash
        run: |
          set -euxo pipefail
          git fetch --tags --force
          git tag "${{ steps.reltag.outputs.tag }}" "${GITHUB_SHA}"
          git push origin "${{ steps.reltag.outputs.tag }}"

  build-and-release:
    needs: preflight
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            runner: ubuntu-24.04
            flavor: standard
            bin: NVRC
            cargo_features: ""
          - target: x86_64-unknown-linux-musl
            runner: ubuntu-24.04
            flavor: confidential
            bin: NVRC-confidential
            cargo_features: "--features=confidential"
          - target: aarch64-unknown-linux-musl
            runner: ubuntu-24.04-arm
            flavor: standard
            bin: NVRC
            cargo_features: ""
          - target: aarch64-unknown-linux-musl
            runner: ubuntu-24.04-arm
            flavor: confidential
            bin: NVRC-confidential
            cargo_features: "--features=confidential"
    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master # v1.70
        with:
          toolchain: stable minus 2 releases
          targets: ${{ matrix.target }}


      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools jq

      - name: Build (${{ matrix.target }} / ${{ matrix.flavor }})
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p dist
          SOURCE_DATE_EPOCH=$(git log -1 --pretty=%ct)
          export SOURCE_DATE_EPOCH
          cargo build --release --target "${{ matrix.target }}" ${{ matrix.cargo_features }}
          cp "target/${{ matrix.target }}/release/NVRC" "dist/${{ matrix.bin }}-${{ matrix.target }}"

      - name: Compute digest (sha256sum format)
        id: hash
        shell: bash
        run: |
          cd dist
          # "<64-hex><space><space><filename>"
          sha256sum "${{ matrix.bin }}-${{ matrix.target }}" | tee "${{ matrix.bin }}-${{ matrix.target }}.sha256"
          # Keep a subjects file in sha256sum format; base64 is computed later
          cp "${{ matrix.bin }}-${{ matrix.target }}.sha256" subjects.txt

      - name: Generate SBOM (SPDX JSON)
        uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
        with:
          file: dist/${{ matrix.bin }}-${{ matrix.target }}
          format: spdx-json
          output-file: dist/sbom-${{ matrix.bin }}-${{ matrix.target }}.spdx.json
          upload-artifact: false   # avoid matrix artifact name collisions (409)

      - name: Install cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Keyless sign binary and SBOM
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          # --- Cosign signing outputs ---
          #   *.sig, *.cert, *.bundle.json (Rekor bundle)
          # We sign two things per build: the binary and the SBOM.

          # Sign binary (+ bundle)
          cosign sign-blob --yes "dist/${{ matrix.bin }}-${{ matrix.target }}" \
            --output-signature "dist/${{ matrix.bin }}-${{ matrix.target }}.sig" \
            --output-certificate "dist/${{ matrix.bin }}-${{ matrix.target }}.cert" \
            --bundle "dist/${{ matrix.bin }}-${{ matrix.target }}.bundle.json"

          # Sign SBOM (SPDX JSON) (+ bundle)
          cosign sign-blob --yes "dist/sbom-${{ matrix.bin }}-${{ matrix.target }}.spdx.json" \
            --output-signature "dist/sbom-${{ matrix.bin }}-${{ matrix.target }}.spdx.json.sig" \
            --output-certificate "dist/sbom-${{ matrix.bin }}-${{ matrix.target }}.spdx.json.cert" \
            --bundle "dist/sbom-${{ matrix.bin }}-${{ matrix.target }}.spdx.json.bundle.json"

      - name: Package release tarball
        shell: bash
        run: |
          set -euxo pipefail
          # SOURCE_DATE_EPOCH isn't persisted across steps; compute a fallback here
          export SOURCE_DATE_EPOCH="${SOURCE_DATE_EPOCH:-$(git log -1 --pretty=%ct)}"
          cd dist
          BASE="${{ matrix.bin }}-${{ matrix.target }}"
          TAR="${BASE}.tar"
          # Create reproducible tarball with stable mtimes/owners
          tar --sort=name --owner=0 --group=0 --numeric-owner --mtime="@${SOURCE_DATE_EPOCH}" \
            -cf "$TAR" \
            "$BASE" "$BASE.sig" "$BASE.cert" \
            "sbom-$BASE.spdx.json" "sbom-$BASE.spdx.json.sig" "sbom-$BASE.spdx.json.cert" \
            "$BASE.bundle.json" "sbom-$BASE.spdx.json.bundle.json"
          xz -T0 -9e -f "$TAR"

      - name: Sign tarball (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          set -euxo pipefail
          BASE="${{ matrix.bin }}-${{ matrix.target }}"
          TARXZ="dist/${BASE}.tar.xz"
          cosign sign-blob --yes "$TARXZ" \
            --output-signature "${TARXZ}.sig" \
            --output-certificate "${TARXZ}.cert" \
            --bundle "${TARXZ}.bundle.json"


      - name: Upload dist as artifact (per combo)
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4
        with:
          name: dist-${{ matrix.target }}-${{ matrix.flavor }}
          path: dist/*
          if-no-files-found: error
          overwrite: true

      - name: Create or update GitHub Release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          name: Release ${{ needs.preflight.outputs.tag }}
          files: |
            dist/${{ matrix.bin }}-${{ matrix.target }}.tar.xz
            dist/${{ matrix.bin }}-${{ matrix.target }}.tar.xz.sig
            dist/${{ matrix.bin }}-${{ matrix.target }}.tar.xz.cert
            dist/${{ matrix.bin }}-${{ matrix.target }}.tar.xz.bundle.json

  provenance-hash-all:
    needs: build-and-release
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: x86_64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
          - target: aarch64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: aarch64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
    outputs:
      map: ${{ steps.mkmap.outputs.map }}
    steps:
      - name: Download all dist artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          pattern: dist-*
          path: dist
          merge-multiple: true
      - name: Build base64 map from *.sha256
        id: mkmap
        shell: bash
        run: |
          set -euo pipefail
          cd dist
          # Build JSON map: { "<bin>-<target>": "<base64(sha256sum line)>", ... }
          echo '{}' > map.json
          for f in *.sha256; do
            [ -f "$f" ] || continue
            key="${f%.sha256}"
            b64=$(base64 -w0 "$f")
            jq --arg k "$key" --arg v "$b64" '. + {($k): $v}' map.json > tmp.json && mv tmp.json map.json
          done
          echo "map=$(jq -c . map.json)" >> "$GITHUB_OUTPUT"

  provenance:

    needs: provenance-hash-all
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: x86_64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
          - target: aarch64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: aarch64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0 # v2.1.0
    with:
      base64-subjects: ${{ fromJSON(needs.provenance-hash-all.outputs.map)[format('{0}-{1}', matrix.bin, matrix.target)] }}
      upload-assets: false

  provenance-publish:
    needs: [preflight, provenance, build-and-release]
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: x86_64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
          - target: aarch64-unknown-linux-musl
            flavor: standard
            bin: NVRC
          - target: aarch64-unknown-linux-musl
            flavor: confidential
            bin: NVRC-confidential
    steps:
      - name: Download provenance artifact for this combo
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          name: ${{ matrix.bin }}-${{ matrix.target }}.intoto.jsonl
          path: prov
      - name: Upload provenance to Release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          files: prov/${{ matrix.bin }}-${{ matrix.target }}.intoto.jsonl

  release-notes:
    needs: [preflight, provenance-publish, build-and-release]
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout repo (for VERIFY.md)
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 1
      - name: Update Release body from repo file
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          body_path: VERIFY.md

  verify-signatures:
    needs: [preflight, provenance-publish, build-and-release]
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Install Rekor CLI and jq
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail

          ASSET=rekor-cli-linux-amd64
          gh release download --repo sigstore/rekor --pattern "${ASSET}" --dir . --clobber
          if gh release download --repo sigstore/rekor --pattern "${ASSET}-keyless.pem" --pattern "${ASSET}-keyless.sig" --dir . --clobber; then
            CERT="${ASSET}-keyless.pem"; SIG="${ASSET}-keyless.sig"
          else
            gh release download --repo sigstore/rekor --pattern "${ASSET}_cert.pem" --dir . --clobber
            gh release download --repo sigstore/rekor --pattern "${ASSET}_signature.sig" --dir . --clobber
            CERT="${ASSET}_cert.pem"; SIG="${ASSET}_signature.sig"
          fi
          cosign verify-blob \
            --certificate "$CERT" \
            --signature   "$SIG" \
            --certificate-identity "keyless@projectsigstore.iam.gserviceaccount.com" \
            --certificate-oidc-issuer "https://accounts.google.com" \
            "${ASSET}"
          chmod +x "${ASSET}"
          sudo mv "${ASSET}" /usr/local/bin/rekor-cli

      - name: Install SLSA verifier
        uses: slsa-framework/slsa-verifier/actions/installer@ea584f4502babc6f60d9bc799dbbb13c1caa9ee6

      - name: Download release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download "${{ needs.preflight.outputs.tag }}" --repo "${{ github.repository }}" --dir .

      - name: Verify binaries, SBOM signatures, Rekor, and SLSA provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail

          # Reusable Cosign identity pins (GitHub Actions keyless cert constraints)
          COSIGN_PINS=(
            --certificate-identity "https://github.com/${{ github.workflow_ref }}"
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com"
            --certificate-github-workflow-repository "${{ github.repository }}"
            --certificate-github-workflow-ref "${{ github.ref }}"
            --certificate-github-workflow-sha "${{ github.sha }}"
            --certificate-github-workflow-name "${{ github.workflow }}"
            --certificate-github-workflow-trigger "${{ github.event_name }}"
          )

          for target in x86_64-unknown-linux-musl aarch64-unknown-linux-musl; do
            for bin in NVRC NVRC-confidential; do
              # 0) If we only have the tarball, verify and extract it first
              if [ -f "${bin}-${target}.tar.xz" ]; then
                # tarball signature (online)
                cosign verify-blob \
                  --rekor-url https://rekor.sigstore.dev \
                  "${COSIGN_PINS[@]}" \
                  --certificate "${bin}-${target}.tar.xz.cert" \
                  --signature   "${bin}-${target}.tar.xz.sig" \
                  "${bin}-${target}.tar.xz"
                # tarball offline (bundle)
                cosign verify-blob \
                  --bundle "${bin}-${target}.tar.xz.bundle.json" \
                  "${COSIGN_PINS[@]}" \
                  "${bin}-${target}.tar.xz"
                tar -xf "${bin}-${target}.tar.xz"
              fi

              # 2) ONLINE verification via Rekor transparency log — binary
              cosign verify-blob \
                --rekor-url https://rekor.sigstore.dev \
                "${COSIGN_PINS[@]}" \
                --certificate "${bin}-${target}.cert" \
                --signature   "${bin}-${target}.sig" \
                "${bin}-${target}"

              # 2c) SBOM signature — online
              cosign verify-blob \
                --rekor-url https://rekor.sigstore.dev \
                "${COSIGN_PINS[@]}" \
                --certificate "sbom-${bin}-${target}.spdx.json.cert" \
                --signature   "sbom-${bin}-${target}.spdx.json.sig" \
                "sbom-${bin}-${target}.spdx.json"

              # 3) OFFLINE verification using Sigstore bundles (no network)
              cosign verify-blob \
                --bundle "${bin}-${target}.bundle.json" \
                "${COSIGN_PINS[@]}" \
                "${bin}-${target}"

              cosign verify-blob \
                --bundle "sbom-${bin}-${target}.spdx.json.bundle.json" \
                "${COSIGN_PINS[@]}" \
                "sbom-${bin}-${target}.spdx.json"

              # 4) Verify SLSA provenance (built from main)
              PROV="${bin}-${target}.intoto.jsonl"
              slsa-verifier verify-artifact "${bin}-${target}" \
                --provenance-path "$PROV" \
                --source-uri "github.com/${{ github.repository }}" \
                --source-branch "main"
            done
          done
