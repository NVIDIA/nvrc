name: Release NVRC

on:
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  id-token: write # Required for OIDC authentication with Sigstore

jobs:
  preflight:
    runs-on: ubuntu-24.04
    outputs:
      tag: ${{ steps.reltag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Install tomlq
        run: |
          python3 -m pip install --user yq
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Derive tag from Cargo.toml
        id: reltag
        shell: bash
        run: |
          set -euo pipefail
          ver=$(tomlq -r '.package.version' Cargo.toml)
          if [[ -z "$ver" ]]; then
            echo "Failed to extract version from Cargo.toml (package.version)" >&2
            exit 1
          fi
          echo "tag=v${ver}" >> "$GITHUB_OUTPUT"

      - name: Fail if Release already exists for this tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.reltag.outputs.tag }}"
          if gh release view "$TAG" --repo "${{ github.repository }}" >/dev/null 2>&1; then
            echo "Release $TAG already exists. Aborting to avoid overwrite." >&2
            exit 1
          fi

      - name: Ensure git tag exists (lightweight)
        shell: bash
        run: |
          set -euxo pipefail
          git fetch --tags --force
          git tag "${{ steps.reltag.outputs.tag }}" "${GITHUB_SHA}"
          git push origin "${{ steps.reltag.outputs.tag }}"

  build-and-release:
    needs: preflight
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            runner: ubuntu-24.04
          - target: aarch64-unknown-linux-musl
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master # v1.70
        with:
          toolchain: stable minus 2 releases
          targets: ${{ matrix.target }}


      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools jq

      - name: Build (${{ matrix.target }})
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p dist
          SOURCE_DATE_EPOCH=$(git log -1 --pretty=%ct)
          export SOURCE_DATE_EPOCH
          cargo build --release --target "${{ matrix.target }}"
          cp "target/${{ matrix.target }}/release/NVRC" "dist/NVRC-${{ matrix.target }}"

      - name: Compute digest (sha256sum format)
        id: hash
        shell: bash
        run: |
          cd dist
          # "<64-hex><space><space><filename>"
          sha256sum "NVRC-${{ matrix.target }}" | tee "NVRC-${{ matrix.target }}.sha256"
          # Keep a subjects file in sha256sum format; base64 is computed later
          cp "NVRC-${{ matrix.target }}.sha256" subjects.txt

      - name: Generate SBOM (SPDX JSON)
        uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
        with:
          file: dist/NVRC-${{ matrix.target }}
          format: spdx-json
          output-file: dist/sbom-NVRC-${{ matrix.target }}.spdx.json
          upload-artifact: false   # avoid matrix artifact name collisions (409)

      - name: Install cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Keyless sign binary and SBOM
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          # --- Cosign signing outputs ---
          #   *.sig, *.cert, *.bundle.json (Rekor bundle)
          # We sign two things per build: the binary and the SBOM.

          # Sign binary (+ bundle)
          cosign sign-blob --yes "dist/NVRC-${{ matrix.target }}" \
            --output-signature "dist/NVRC-${{ matrix.target }}.sig" \
            --output-certificate "dist/NVRC-${{ matrix.target }}.cert" \
            --bundle "dist/NVRC-${{ matrix.target }}.bundle.json"

          # Sign SBOM (SPDX JSON) (+ bundle)
          cosign sign-blob --yes "dist/sbom-NVRC-${{ matrix.target }}.spdx.json" \
            --output-signature "dist/sbom-NVRC-${{ matrix.target }}.spdx.json.sig" \
            --output-certificate "dist/sbom-NVRC-${{ matrix.target }}.spdx.json.cert" \
            --bundle "dist/sbom-NVRC-${{ matrix.target }}.spdx.json.bundle.json"

      - name: Package release tarball
        shell: bash
        run: |
          set -euxo pipefail
          # SOURCE_DATE_EPOCH isn't persisted across steps; compute a fallback here
          export SOURCE_DATE_EPOCH="${SOURCE_DATE_EPOCH:-$(git log -1 --pretty=%ct)}"
          cd dist
          BASE="NVRC-${{ matrix.target }}"
          TAR="${BASE}.tar"
          # Create reproducible tarball with stable mtimes/owners
          tar --sort=name --owner=0 --group=0 --numeric-owner --mtime="@${SOURCE_DATE_EPOCH}" \
            -cf "$TAR" \
            "$BASE" "$BASE.sig" "$BASE.cert" \
            "sbom-$BASE.spdx.json" "sbom-$BASE.spdx.json.sig" "sbom-$BASE.spdx.json.cert" \
            "$BASE.bundle.json" "sbom-$BASE.spdx.json.bundle.json"
          xz -T0 -9e -f "$TAR"

      - name: Sign tarball (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          set -euxo pipefail
          BASE="NVRC-${{ matrix.target }}"
          TARXZ="dist/${BASE}.tar.xz"
          cosign sign-blob --yes "$TARXZ" \
            --output-signature "${TARXZ}.sig" \
            --output-certificate "${TARXZ}.cert" \
            --bundle "${TARXZ}.bundle.json"


      - name: Upload dist as artifact (per target)
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4
        with:
          name: dist-${{ matrix.target }}
          path: dist/*
          if-no-files-found: error
          overwrite: true

  create-release:
    needs: [preflight, build-and-release]
    runs-on: ubuntu-24.04
    steps:
      - name: Download all dist artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          pattern: dist-*
          path: dist
          merge-multiple: true

      - name: Create draft GitHub Release and upload tarballs
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          name: Release ${{ needs.preflight.outputs.tag }}
          draft: true
          files: |
            dist/NVRC-x86_64-unknown-linux-musl.tar.xz
            dist/NVRC-x86_64-unknown-linux-musl.tar.xz.sig
            dist/NVRC-x86_64-unknown-linux-musl.tar.xz.cert
            dist/NVRC-x86_64-unknown-linux-musl.tar.xz.bundle.json
            dist/NVRC-aarch64-unknown-linux-musl.tar.xz
            dist/NVRC-aarch64-unknown-linux-musl.tar.xz.sig
            dist/NVRC-aarch64-unknown-linux-musl.tar.xz.cert
            dist/NVRC-aarch64-unknown-linux-musl.tar.xz.bundle.json

  provenance-hash-all:
    needs: build-and-release
    runs-on: ubuntu-24.04
    outputs:
      map: ${{ steps.mkmap.outputs.map }}
    steps:
      - name: Download all dist artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          pattern: dist-*
          path: dist
          merge-multiple: true
      - name: Build base64 map from *.sha256
        id: mkmap
        shell: bash
        run: |
          set -euo pipefail
          cd dist
          # Build JSON map: { "<bin>-<target>": "<base64(sha256sum line)>", ... }
          echo '{}' > map.json
          for f in *.sha256; do
            [ -f "$f" ] || continue
            key="${f%.sha256}"
            b64=$(base64 -w0 "$f")
            jq --arg k "$key" --arg v "$b64" '. + {($k): $v}' map.json > tmp.json && mv tmp.json map.json
          done
          echo "map=$(jq -c . map.json)" >> "$GITHUB_OUTPUT"

  provenance:
    needs: provenance-hash-all
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-musl
          - aarch64-unknown-linux-musl
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0 # v2.1.0
    with:
      base64-subjects: ${{ fromJSON(needs.provenance-hash-all.outputs.map)[format('NVRC-{0}', matrix.target)] }}
      upload-assets: false

  provenance-publish:
    needs: [preflight, provenance, create-release]
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-musl
          - aarch64-unknown-linux-musl
    steps:
      - name: Download provenance artifact for this target
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          name: NVRC-${{ matrix.target }}.intoto.jsonl
          path: prov
      - name: Upload provenance to draft Release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          draft: true
          files: prov/NVRC-${{ matrix.target }}.intoto.jsonl

  release-notes:
    needs: [preflight, provenance-publish, create-release]
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout repo (for VERIFY.md)
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 1
      - name: Update draft Release body from repo file
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          draft: true
          body_path: VERIFY.md

  publish-release:
    needs: [preflight, release-notes]
    runs-on: ubuntu-24.04
    steps:
      - name: Verify draft release has all required assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ needs.preflight.outputs.tag }}"

          # Get list of assets in the draft release
          ASSETS=$(gh release view "$TAG" --repo "${{ github.repository }}" --json assets --jq '.assets[].name' | sort)

          # Define expected assets
          EXPECTED=(
            "NVRC-x86_64-unknown-linux-musl.tar.xz"
            "NVRC-x86_64-unknown-linux-musl.tar.xz.sig"
            "NVRC-x86_64-unknown-linux-musl.tar.xz.cert"
            "NVRC-x86_64-unknown-linux-musl.tar.xz.bundle.json"
            "NVRC-x86_64-unknown-linux-musl.intoto.jsonl"
            "NVRC-aarch64-unknown-linux-musl.tar.xz"
            "NVRC-aarch64-unknown-linux-musl.tar.xz.sig"
            "NVRC-aarch64-unknown-linux-musl.tar.xz.cert"
            "NVRC-aarch64-unknown-linux-musl.tar.xz.bundle.json"
            "NVRC-aarch64-unknown-linux-musl.intoto.jsonl"
          )

          MISSING=()
          for asset in "${EXPECTED[@]}"; do
            if ! echo "$ASSETS" | grep -qx "$asset"; then
              MISSING+=("$asset")
            fi
          done

          if [[ ${#MISSING[@]} -gt 0 ]]; then
            echo "ERROR: Draft release is missing required assets:" >&2
            printf '  - %s\n' "${MISSING[@]}" >&2
            exit 1
          fi

          echo "All ${#EXPECTED[@]} required assets present in draft release"

      - name: Publish draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release edit "${{ needs.preflight.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            --draft=false

  verify-signatures:
    needs: [preflight, publish-release]
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Install Rekor CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail

          ASSET=rekor-cli-linux-amd64
          gh release download --repo sigstore/rekor --pattern "${ASSET}" --dir . --clobber
          gh release download --repo sigstore/rekor --pattern "${ASSET}-keyless.sigstore.json" --dir . --clobber
          cosign verify-blob \
            --bundle "${ASSET}-keyless.sigstore.json" \
            --certificate-identity "keyless@projectsigstore.iam.gserviceaccount.com" \
            --certificate-oidc-issuer "https://accounts.google.com" \
            "${ASSET}"
          chmod +x "${ASSET}"
          sudo mv "${ASSET}" /usr/local/bin/rekor-cli

      - name: Install SLSA verifier
        uses: slsa-framework/slsa-verifier/actions/installer@ea584f4502babc6f60d9bc799dbbb13c1caa9ee6

      - name: Download release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download "${{ needs.preflight.outputs.tag }}" --repo "${{ github.repository }}" --dir .

      - name: Verify binaries, SBOM signatures, Rekor, and SLSA provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail

          # Reusable Cosign identity pins (GitHub Actions keyless cert constraints)
          COSIGN_PINS=(
            --certificate-identity "https://github.com/${{ github.workflow_ref }}"
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com"
            --certificate-github-workflow-repository "${{ github.repository }}"
            --certificate-github-workflow-ref "${{ github.ref }}"
            --certificate-github-workflow-sha "${{ github.sha }}"
            --certificate-github-workflow-name "${{ github.workflow }}"
            --certificate-github-workflow-trigger "${{ github.event_name }}"
          )

          for target in x86_64-unknown-linux-musl aarch64-unknown-linux-musl; do
            bin=NVRC
            # 0) If we only have the tarball, verify and extract it first
            if [ -f "${bin}-${target}.tar.xz" ]; then
              # tarball signature (online)
              cosign verify-blob \
                --rekor-url https://rekor.sigstore.dev \
                "${COSIGN_PINS[@]}" \
                --certificate "${bin}-${target}.tar.xz.cert" \
                --signature   "${bin}-${target}.tar.xz.sig" \
                "${bin}-${target}.tar.xz"
              # tarball offline (bundle)
              cosign verify-blob \
                --bundle "${bin}-${target}.tar.xz.bundle.json" \
                "${COSIGN_PINS[@]}" \
                "${bin}-${target}.tar.xz"
              tar -xf "${bin}-${target}.tar.xz"
            fi

            # 2) ONLINE verification via Rekor transparency log — binary
            cosign verify-blob \
              --rekor-url https://rekor.sigstore.dev \
              "${COSIGN_PINS[@]}" \
              --certificate "${bin}-${target}.cert" \
              --signature   "${bin}-${target}.sig" \
              "${bin}-${target}"

            # 2c) SBOM signature — online
            cosign verify-blob \
              --rekor-url https://rekor.sigstore.dev \
              "${COSIGN_PINS[@]}" \
              --certificate "sbom-${bin}-${target}.spdx.json.cert" \
              --signature   "sbom-${bin}-${target}.spdx.json.sig" \
              "sbom-${bin}-${target}.spdx.json"

            # 3) OFFLINE verification using Sigstore bundles (no network)
            cosign verify-blob \
              --bundle "${bin}-${target}.bundle.json" \
              "${COSIGN_PINS[@]}" \
              "${bin}-${target}"

            cosign verify-blob \
              --bundle "sbom-${bin}-${target}.spdx.json.bundle.json" \
              "${COSIGN_PINS[@]}" \
              "sbom-${bin}-${target}.spdx.json"

            # 4) Verify SLSA provenance (built from main)
            PROV="${bin}-${target}.intoto.jsonl"
            slsa-verifier verify-artifact "${bin}-${target}" \
              --provenance-path "$PROV" \
              --source-uri "github.com/${{ github.repository }}" \
              --source-branch "main"
          done
